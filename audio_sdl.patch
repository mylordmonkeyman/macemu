diff --git a/SheepShaver/src/SDL/audio_sdl.cpp b/SheepShaver/src/SDL/audio_sdl.cpp
index 0000000..0000000 100644
--- a/SheepShaver/src/SDL/audio_sdl.cpp
+++ b/SheepShaver/src/SDL/audio_sdl.cpp
@@
 #include "my_sdl.h"
 
+#ifdef LIBRETRO
+#include "../Unix/audio_libretro_shim.h"
+#include "../Unix/libretro_bridge.h"
+#endif
+
 /*...*/
@@
 static bool open_sdl_audio(void)
 {
@@
-	// Open the audio device, forcing the desired format
-	if (SDL_OpenAudio(&audio_spec, NULL) < 0) {
-		fprintf(stderr, "WARNING: Cannot open audio: %s\n", SDL_GetError());
-		return false;
-	}
-	
-#if SDL_VERSION_ATLEAST(2,0,0)
-	// HACK: workaround a bug in SDL pre-2.0.6 (reported via https://bugzilla.libsdl.org/show_bug.cgi?id=3710 )
-	// whereby SDL does not update audio_spec.size
-	if (audio_spec.size == 0) {
-		audio_spec.size = (SDL_AUDIO_BITSIZE(audio_spec.format) / 8) * audio_spec.channels * audio_spec.samples;
-	}
-#endif
-
-#if defined(BINCUE)
-	OpenAudio_bincue(audio_spec.freq, audio_spec.format, audio_spec.channels,
-	audio_spec.silence, get_audio_volume());
-#endif
-
-#if SDL_VERSION_ATLEAST(2,0,0)
-	const char * driver_name = SDL_GetCurrentAudioDriver();
-#else
-	char driver_name[32];
-	SDL_AudioDriverName(driver_name, sizeof(driver_name) - 1);
-#endif
-	printf("Using SDL/%s audio output\n", driver_name ? driver_name : "");
-	silence_byte = audio_spec.silence;
-	SDL_PauseAudio(0);
-
-	// Sound buffer size = 4096 frames
-	audio_frames_per_block = audio_spec.samples;
-	audio_mix_buf = (uint8*)malloc(audio_spec.size);
-	return true;
+	/* In LIBRETRO builds we don't open native audio devices. Instead, tell
+	 * the libretro bridge the sample rate and allocate the mixing buffer.
+	 */
+#ifdef LIBRETRO
+	sheepbridge_set_sample_rate((unsigned)audio_spec.freq);
+	silence_byte = audio_spec.silence;
+	audio_frames_per_block = audio_spec.samples;
+	audio_mix_buf = (uint8*)malloc(audio_spec.size);
+	if (!audio_mix_buf) {
+		fprintf(stderr, "WARNING: Cannot allocate audio_mix_buf\n");
+		return false;
+	}
+	printf("Using LIBRETRO audio output (SDL shim), freq %d chan %d\n", audio_spec.freq, audio_spec.channels);
+	return true;
+#else
+	// Open the audio device, forcing the desired format
+	if (SDL_OpenAudio(&audio_spec, NULL) < 0) {
+		fprintf(stderr, "WARNING: Cannot open audio: %s\n", SDL_GetError());
+		return false;
+	}
+	
+	#if SDL_VERSION_ATLEAST(2,0,0)
+	// HACK: workaround a bug in SDL pre-2.0.6 whereby SDL does not update audio_spec.size
+	if (audio_spec.size == 0) {
+		audio_spec.size = (SDL_AUDIO_BITSIZE(audio_spec.format) / 8) * audio_spec.channels * audio_spec.samples;
+	}
+	#endif
+
+	#if defined(BINCUE)
+	OpenAudio_bincue(audio_spec.freq, audio_spec.format, audio_spec.channels,
+	audio_spec.silence, get_audio_volume());
+	#endif
+
+	#if SDL_VERSION_ATLEAST(2,0,0)
+	const char * driver_name = SDL_GetCurrentAudioDriver();
+	#else
+	char driver_name[32];
+	SDL_AudioDriverName(driver_name, sizeof(driver_name) - 1);
+	#endif
+	printf("Using SDL/%s audio output\n", driver_name ? driver_name : "");
+	silence_byte = audio_spec.silence;
+	SDL_PauseAudio(0);
+
+	// Sound buffer size = 4096 frames
+	audio_frames_per_block = audio_spec.samples;
+	audio_mix_buf = (uint8*)malloc(audio_spec.size);
+	return true;
+#endif /* LIBRETRO */
 }
@@
 static void stream_func(void *arg, uint8 *stream, int stream_len)
 {
 	if (AudioStatus.num_sources) {
@@
-			// Send data to audio device
-			bool dbl = AudioStatus.channels == 2 &&
-				ReadMacInt16(apple_stream_info + scd_numChannels) == 1 &&
-				ReadMacInt16(apple_stream_info + scd_sampleSize) == 8;
-			uint8 *src = Mac2HostAddr(ReadMacInt32(apple_stream_info + scd_buffer));
-			if (dbl)
-				for (int i = 0; i < work_size; i += 2)
-					audio_mix_buf[i] = audio_mix_buf[i + 1] = src[i >> 1];
-			else memcpy(audio_mix_buf, src, work_size);
-			memset((uint8 *)stream, silence_byte, stream_len);
-			SDL_MixAudio(stream, audio_mix_buf, work_size, get_audio_volume());
-
-			D(bug("stream: data written\n"));
+			// Prepare mixed PCM in audio_mix_buf
+			bool dbl = AudioStatus.channels == 2 &&
+				ReadMacInt16(apple_stream_info + scd_numChannels) == 1 &&
+				ReadMacInt16(apple_stream_info + scd_sampleSize) == 8;
+			uint8 *src = Mac2HostAddr(ReadMacInt32(apple_stream_info + scd_buffer));
+			if (dbl) {
+				for (int i = 0; i < work_size; i += 2)
+					audio_mix_buf[i] = audio_mix_buf[i + 1] = src[i >> 1];
+			} else {
+				memcpy(audio_mix_buf, src, work_size);
+			}
+
+#ifdef LIBRETRO
+			/* Forward mixed PCM into libretro bridge via the shim.
+			 * work_size is bytes. Determine sample size & channels from AudioStatus.
+			 */
+			int sample_size_bytes = (AudioStatus.sample_size >> 3);
+			int channels = AudioStatus.channels ? AudioStatus.channels : 2;
+			if (sample_size_bytes <= 0) sample_size_bytes = 2;
+			size_t frames = (size_t)work_size / ((size_t)sample_size_bytes * (size_t)channels);
+
+			if (sample_size_bytes == 2 && channels == 2) {
+				send_s16_stereo_to_host((const int16_t *)audio_mix_buf, frames);
+			} else {
+				send_audio_to_host(audio_mix_buf, frames, sample_size_bytes, channels);
+			}
+			D(bug("stream: forwarded %zu frames to libretro bridge\n", frames));
+#else
+			memset((uint8 *)stream, silence_byte, stream_len);
+			SDL_MixAudio(stream, audio_mix_buf, work_size, get_audio_volume());
+			D(bug("stream: data written\n"));
+#endif
*** End Patch
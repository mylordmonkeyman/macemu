diff --git a/SheepShaver/src/SDL/audio_sdl3.cpp b/SheepShaver/src/SDL/audio_sdl3.cpp
index 0000000..0000000 100644
--- a/SheepShaver/src/SDL/audio_sdl3.cpp
+++ b/SheepShaver/src/SDL/audio_sdl3.cpp
@@
 #include "my_sdl.h"
 
+#ifdef LIBRETRO
+#include "../Unix/audio_libretro_shim.h"
+#include "../Unix/libretro_bridge.h"
+#endif
+
 /*...*/
@@
-	SDL_AudioStream *stream = SDL_OpenAudioDeviceStream(SDL_AUDIO_DEVICE_DEFAULT_PLAYBACK, &audio_spec, stream_func, NULL);
-	if (stream == NULL) {
-		fprintf(stderr, "WARNING: Cannot open audio: %s\n", SDL_GetError());
-		return false;
-	}
-	main_open_sdl_stream = stream;
-	silence_byte = SDL_GetSilenceValueForFormat(audio_spec.format);
-#if defined(BINCUE)
-	OpenAudio_bincue(audio_spec.freq, audio_spec.format, audio_spec.channels, silence_byte, (int)(get_audio_volume()*128));
-#endif
-
-	printf("Using SDL/%s audio output\n", SDL_GetCurrentAudioDriver());
-	audio_frames_per_block = 4096 >> PrefsFindInt32("sound_buffer");
-	start_threads();
-	SDL_ResumeAudioDevice(SDL_GetAudioStreamDevice(stream));
-	return true;
+#ifdef LIBRETRO
+	/* LIBRETRO: do not open native SDL audio device. Inform bridge & allocate buffer */
+	sheepbridge_set_sample_rate((unsigned)audio_spec.freq);
+	main_open_sdl_stream = NULL;
+	silence_byte = SDL_GetSilenceValueForFormat(audio_spec.format);
+	audio_frames_per_block = audio_spec.samples;
+	audio_mix_buf = (uint8*)malloc((size_t)audio_spec.size);
+	if (!audio_mix_buf) {
+		fprintf(stderr, "WARNING: Cannot allocate audio_mix_buf\n");
+		return false;
+	}
+#if defined(BINCUE)
+	OpenAudio_bincue(audio_spec.freq, audio_spec.format, audio_spec.channels, silence_byte, (int)(get_audio_volume()*128));
+#endif
+	printf("Using LIBRETRO audio output (SDL3 shim), freq %d chan %d\n", audio_spec.freq, audio_spec.channels);
+	start_threads();
+	return true;
+#else
+	SDL_AudioStream *stream = SDL_OpenAudioDeviceStream(SDL_AUDIO_DEVICE_DEFAULT_PLAYBACK, &audio_spec, stream_func, NULL);
+	if (stream == NULL) {
+		fprintf(stderr, "WARNING: Cannot open audio: %s\n", SDL_GetError());
+		return false;
+	}
+	main_open_sdl_stream = stream;
+	silence_byte = SDL_GetSilenceValueForFormat(audio_spec.format);
+#if defined(BINCUE)
+	OpenAudio_bincue(audio_spec.freq, audio_spec.format, audio_spec.channels, silence_byte, (int)(get_audio_volume()*128));
+#endif
+	printf("Using SDL/%s audio output\n", SDL_GetCurrentAudioDriver());
+	audio_frames_per_block = 4096 >> PrefsFindInt32("sound_buffer");
+	start_threads();
+	SDL_ResumeAudioDevice(SDL_GetAudioStreamDevice(stream));
+	return true;
+#endif
 }
@@
-	memset(dst, silence_byte, stream_len);
-	//SDL_AudioSpec audio_spec;
-	//int r = SDL_GetAudioStreamFormat(stream, NULL, &audio_spec);// little endianが帰ってくる
-	SDL_MixAudio(dst, src, audio_spec.format, stream_len, get_audio_volume());
-#if defined(BINCUE)
-	MixAudio_bincue(dst, stream_len);
-#endif
-	SDL_PutAudioStreamData(stream, dst, stream_len);
+	memset(dst, silence_byte, stream_len);
+	//SDL_AudioSpec audio_spec;
+	//int r = SDL_GetAudioStreamFormat(stream, NULL, &audio_spec);// little endianが帰ってくる
+#ifdef LIBRETRO
+	SDL_MixAudio(dst, src, audio_spec.format, stream_len, get_audio_volume());
+#if defined(BINCUE)
+	MixAudio_bincue(dst, stream_len);
+#endif
+	int bits = SDL_AUDIO_BITSIZE(audio_spec.format);
+	int sample_size_bytes = bits / 8;
+	int channels = audio_spec.channels;
+	if (sample_size_bytes <= 0) sample_size_bytes = 2;
+	size_t frames = (size_t)stream_len / ((size_t)sample_size_bytes * (size_t)channels);
+	if (sample_size_bytes == 2 && channels == 2) {
+		send_s16_stereo_to_host((const int16_t *)dst, frames);
+	} else {
+		send_audio_to_host(dst, frames, sample_size_bytes, channels);
+	}
+#else
+	SDL_MixAudio(dst, src, audio_spec.format, stream_len, get_audio_volume());
+#if defined(BINCUE)
+	MixAudio_bincue(dst, stream_len);
+#endif
+	SDL_PutAudioStreamData(stream, dst, stream_len);
+#endif
*** End Patch